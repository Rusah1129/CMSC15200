/* Ruhi Sah, rsah
 * CS 152, Winter 2020
 * PROJ 2
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "logic.h"

game* new_game(unsigned int run, unsigned int width, unsigned int height,
    enum type type)
{

    if (run > width && run > height) {
        fprintf(stderr, "run must be smaller than width or height");
        exit(1);
    }

    if (run <= 1) {
        fprintf(stderr, "run must be greater than 1");
        exit(1);
    }

    game* new_game = (game*) malloc (sizeof(game));
    new_game -> run = run;
    new_game -> b = board_new(width, height, type);
    new_game -> next = BLACK_NEXT;
    return new_game;
}

void game_free(game* g) {
    board_free(g -> b);
    free(g);
}

int drop_piece(game* g, unsigned int col) {
    int i;
    for (i = g -> b -> height; i >= 0; i--) {
        struct pos pos = make_pos(i - 1, col);
        if (board_get(g -> b, pos) == EMPTY) {
           if (g -> next == BLACK_NEXT) {
                board_set(g -> b, pos, BLACK);
                return 1;
            } else if (g -> next == WHITE_NEXT) {
                board_set(g -> b, pos, WHITE);
                return 1;
            }
        }
    }
    return 0;
}

void twist(game* g, direction d)
{
    signed int i, j;
    unsigned int new_pos;
    board* new_board = board_new(g -> b -> height, g -> b -> width, MATRIX);
    switch (d)
    {
        case CW:
            for (i = g -> b -> height - 1; i >= 0; i--) {
              for (j = g -> b -> width - 1; j >= 0; j--) {
                    struct pos pos = make_pos(i, j);
                    if (board_get(g -> b, pos) != EMPTY) {
                       if (board_get(g -> b, pos) == BLACK) {
                            struct pos pos2 = make_pos((g -> b -> width)
                                - new_pos - 1, 
                                (g -> b -> height) - i - 1);
                            board_set(new_board, pos2, BLACK);
                            new_pos++;
                        } else {
                            struct pos pos2 = make_pos((g -> b -> width)
                                - new_pos - 1,
                                (g -> b -> height) - i - 1);
                            board_set(new_board, pos2, WHITE);
                            new_pos++;
                        }   
                    }   
               }    
               new_pos = 0;
            }  
            g -> b = new_board;
            break; 
        case CCW:
            for (i = g -> b -> height - 1; i >= 0; i--) {
              for (j = 0; j < g -> b -> width; j++) {
                    struct pos pos = make_pos(i, j);
                    if (board_get(g -> b, pos) != EMPTY) {
                       if (board_get(g -> b, pos) == BLACK) {
                            struct pos pos2 = make_pos((g -> b -> width)
                                - new_pos - 1, i);
                            board_set(new_board, pos2, BLACK);
                            new_pos++;
                        } else {
                            struct pos pos2 = make_pos((g -> b -> width)
                                - new_pos - 1, i);
                            board_set(new_board, pos2, WHITE);
                            new_pos++;
                        }   
                    }
               }
               new_pos = 0;
            }
            g -> b = new_board;
            break;
    }
}

/* checks if there's "run" amounts of a certain cell vertically */
int recursive3(int i, int j, game* g, int counter, enum cell cell) {
    struct pos pos = make_pos(i, j);
    if (i < g -> b -> height && j < g -> b -> width) {
        if (board_get(g -> b, pos) == cell && counter <= g -> run) {
            counter++;
            if (counter == g -> run) {
                return 1;
            } else {
                return recursive3(i + 1, j, g, counter, cell);

            }
        }
    } return 0;
}

/* check if a specified cell has "run" in a row vertically */
int check_vertical(game* g, enum cell cell) {
    unsigned int i, j;
    unsigned int counter = 0;
    for (i = 0; i < g -> b -> height; i++) {
        for (j = 0; j < g -> b -> width; j++) {
            struct pos pos = make_pos(i, j);
            if (board_get(g -> b, pos) == cell) {
                if (recursive3(i + 1, j, g, counter + 1, cell) == 1) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* checks if there's "run" amounts of a certain cell horizontally */
int recursive2(int i, int j, game* g, int counter, enum cell cell) {
    struct pos pos = make_pos(i, j);
    if (i < g -> b -> height && j < g -> b -> width) {
        if (board_get(g -> b, pos) == cell && counter <= g -> run) {
            counter++;
            if (counter == g -> run) {
                return 1;
            } else {
                return recursive2(i, j + 1, g, counter, cell);

            }
        }
    } return 0;
}

/* check if a specified cell has "run" in a row horizontally */
int check_horizontal(game* g, enum cell cell) {
    unsigned int i, j;
    unsigned int counter = 0;
    for (i = 0; i < g -> b -> height; i++) {
        for (j = 0; j < g -> b -> width; j++) {
            struct pos pos = make_pos(i, j);
            if (board_get(g -> b, pos) == cell) {
                if (recursive2(i, j + 1, g, counter + 1, cell) == 1) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* checks if there's "run" of a certain cell diagonally, right-down */
int recursive(int i, int j, game* g, int counter, enum cell cell) {
    struct pos pos = make_pos(i, j);
    if (i < g -> b -> height && j < g -> b -> width) {
        if (board_get(g -> b, pos) == cell && counter < g -> run) {
            counter++;
            if (counter == g -> run) {
                return 1;
            } else {
                return recursive(i + 1, j + 1, g, counter, cell);

            }
        }
    } return 0;
}

/* checks if there's "run" of a certain cell diagonally, left-down */
int recursive_b(int i, int j, game* g, int counter, enum cell cell) {
    struct pos pos = make_pos(i, j);
    if (i < g -> b -> height  && j < g -> b -> width) {
        if (board_get(g -> b, pos) == cell && counter < g -> run) {
            counter++;
            if (counter == g -> run) {
                return 1;
            } else {
                return recursive_b(i + 1, j - 1, g, counter, cell);

            }
        }
    } return 0;
}

/* check if a specified cell has "run" in a row diagonally */
int check_diagonal(game* g, enum cell cell) {
    unsigned int i, j;
    unsigned int counter = 0;
    for (i = 0; i < g -> b -> height; i++) {
        for (j = 0; j < g -> b -> width; j++) {
            struct pos pos = make_pos(i, j);
            if (board_get(g -> b, pos) == cell) {
                if (recursive(i + 1, j + 1, g, counter + 1, cell) == 1) {
                    return 1;
                }
            }
        }
    }
    counter = 0;
    for (i = 0; i < g -> b -> height; i++) {
        for (j = 0; j < g -> b -> width; j++) {
            struct pos pos = make_pos(i, j);
            if (board_get(g -> b, pos) == cell) {
                if (recursive_b(i + 1, j - 1, g, counter + 1, cell) == 1) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* if black has "run" in a row, return 1, else return 0 */
int black_wins(game* g) {
    if (check_diagonal(g, BLACK) == 1 || check_vertical(g, BLACK) == 1 ||
        check_horizontal(g, BLACK) == 1) {
        return 1;
    }
    return 0;
}

/* if white has "run" in a row, return 1, else return 0 */
int white_wins(game* g) {
    if (check_diagonal(g, WHITE) == 1 || check_vertical(g, WHITE) == 1 ||
        check_horizontal(g, WHITE) == 1) {
        return 1;
    }
    return 0;
}

outcome game_outcome(game* g) {
    if (black_wins(g) == 1 && white_wins(g) == 1) {
        return DRAW;
    } else if (white_wins(g) == 1) {
        return WHITE_WIN;
    } else if (black_wins(g) == 1) {
        return BLACK_WIN;
    }

    return IN_PROGRESS;
}
