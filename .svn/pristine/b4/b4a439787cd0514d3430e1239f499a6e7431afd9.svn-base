/* Ruhi Sah, rsah
 * CS 152, Winter 2020
 * PROJ 1
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "logic.h"

game* new_game(unsigned int run, unsigned int width, unsigned int height,
    enum type type) 
{
    game* new_game = (game*) malloc (sizeof(game));
    new_game -> run = run;
    new_game -> b = board_new(width, height, type);;
    new_game -> next = BLACK_NEXT;
    return new_game;
}

void game_free(game* g) {
    board_free(g -> b);
    free(g);
}

int drop_piece(game* g, unsigned int col) {
    int i;
    for (i = g -> b -> height; i >= 0; i--) {
        struct pos pos = make_pos(i - 1, col);
        if (board_get(g -> b, pos) == EMPTY) {
            if (g -> next == BLACK_NEXT) {
                board_set(g -> b, pos, BLACK);
                return 1;
            } else if (g -> next == WHITE_NEXT) {
                board_set(g -> b, pos, WHITE);
                return 1;
            }
        }
    }   
    return 0;
}

void twist(game* g, direction d) 
{
    signed int i, j;
    unsigned int new_pos = g -> b -> height;
    board* new_board = board_new(g -> b -> height, g -> b -> width, MATRIX);
    switch (d)
    {
        case CW:
            for (i = g -> b -> height - 1; i >= 0; i--) {
              for (j = g -> b -> width - 1; j >= 0; j--) {
                    struct pos pos = make_pos(i, j);
                    if (board_get(g -> b, pos) != EMPTY) {
                       if (board_get(g -> b, pos) == BLACK) {
                            printf("%d %d ", i, j);
                            struct pos pos2 = make_pos(new_pos, 
                                i - (g -> b -> width));
                            board_set(new_board, pos2, BLACK);
                            new_pos = j;
                        } else {
                            struct pos pos2 = make_pos(j, i);
                            board_set(new_board, pos2, WHITE);
                            new_pos = j;
                        }
                    }  
               }
               new_pos = g -> b -> width;
            }
            g -> b = new_board;
            break;
        case CCW:
            for (i = 0; i < g -> b -> height; i++) {
                for (j = 0; j >= g -> b -> width; j++) {
                    struct pos pos = make_pos(i, j);
                    if (board_get(g -> b, pos) != EMPTY) {
                        if (board_get(g -> b, pos) == BLACK) {
                            board_set(new_board, pos, BLACK);
                            new_pos = 0;
                        } else {
                            board_set(new_board, pos, WHITE);
                            new_pos = 0;
                        }
                    }
                }
                new_pos = g -> b -> width;
            }
            break;
    }
}


int recursive3(int i, int j, game* g, int counter, enum cell cell) {
    struct pos pos = make_pos(i, j);
    if (i < g -> b -> height && j < g -> b -> width) {
        if (board_get(g -> b, pos) == cell && counter <= g -> run) {
            counter++;
            if (counter == g -> run) {
                return 1;
            } else {
                return recursive3(i + 1, j, g, counter, cell);

            }
        }
    } return 0;
}

int check_vertical(game* g, enum cell cell) {
    unsigned int i, j;
    unsigned int counter = 0;
    for (i = 0; i < g -> b -> height; i++) {
        for (j = 0; j < g -> b -> width; j++) {
            struct pos pos = make_pos(i, j);
            if (board_get(g -> b, pos) == cell) {
                if (recursive3(i + 1, j, g, counter + 1, cell) == 1) {
                    return 1;
                }
            }
        }
    }  
    return 0;
}

int recursive2(int i, int j, game* g, int counter, enum cell cell) {
    struct pos pos = make_pos(i, j);
    if (i < g -> b -> height && j < g -> b -> width) {
        if (board_get(g -> b, pos) == cell && counter <= g -> run) {
            counter++;
            if (counter == g -> run) {
                return 1;
            } else {
                return recursive2(i, j + 1, g, counter, cell);

            }
        }
    } return 0;
}


int check_horizontal(game* g, enum cell cell) {
    unsigned int i, j;
    unsigned int counter = 0;
    for (i = 0; i < g -> b -> height; i++) {
        for (j = 0; j < g -> b -> width; j++) {
            struct pos pos = make_pos(i, j);
            if (board_get(g -> b, pos) == cell) {
                if (recursive2(i, j + 1, g, counter + 1, cell) == 1) {
                    return 1;
                }
            }
        }
    }   
    return 0;
}

int recursive(int j, int i, game* g, int counter, enum cell cell) {
    struct pos pos = make_pos(j, i);
    if (i < g -> b -> height && j < g -> b -> width) {
        if (board_get(g -> b, pos) == cell && counter < g -> run) {
            counter++;
            if (counter == g -> run) {
                return 1;
            } else {
                return recursive(j + 1, i + 1, g, counter, cell);
                
            }
        }
    } return 0;
}

int check_diagonal(game* g, enum cell cell) {
    unsigned int i, j;
    unsigned int counter = 0;
    for (i = 0; i < g -> b -> height; i++) {
        for (j = 0; j < g -> b -> width; j++) {
            struct pos pos = make_pos(i, j);
            if (board_get(g -> b, pos) == cell) {
                if (recursive(j + 1, i + 1, g, counter + 1, cell) == 1) {
                    return 1;
                } 
            }
        }
    }
    return 0;
}

int black_wins(game* g) {
    if (check_diagonal(g, BLACK) == 1 || check_vertical(g, BLACK) == 1 ||
        check_horizontal(g, BLACK) == 1) {
        return 1;
    }
    return 0;
}

int white_wins(game* g) {
    if (check_diagonal(g, WHITE) == 1 || check_vertical(g, WHITE) == 1 ||
        check_horizontal(g, WHITE) == 1) {
        return 1;
    }
    return 0;
}

outcome game_outcome(game* g) {
    if (black_wins(g) == 1) {
        printf("black wins!");
        printf("\n");
    }
    if (white_wins(g) == 1) {
        printf("white wins!");
        printf("\n");
    }
    return BLACK_WIN;
} 
